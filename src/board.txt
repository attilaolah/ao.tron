The tron board
--------------

The class :class:`yatronBoard` represents the state of the tron board in
discrete time. It has some utility functions to make it easier for your bot
to work with the board object. To construct a simple board object, we'll use
the :func:`yatron.generate` generator.

    >>> import sys
    >>> from StringIO import StringIO
    >>> sys.stdin = StringIO("""5 5
    ... #####
    ... #  2#
    ... #   #
    ... #1  #
    ... #####
    ... """)

    >>> from yatron import generate
    >>> board = generate().next()
    >>> board
    <Board (5x5)>

To see that we actually have the correct board, we can use the
:attr:`yatron.Board.board` property. Note that this property is lazy, as are
most other properties: they won't calculate the result unless you ask for it,
and once calculated, they store it in the object for later use.

    >>> print board.board
    #####
    #  2#
    #   #
    #1  #
    #####

We can ask our coordinates using the :attr:`yatron.Board.me` property (or it's
alias, :attr:`yatron.Board.m`).

    >>> me = board.me
    >>> me
    (1, 1)

Similarly, we can use :attr:`yatron.Board.them` (and it's alias,
:attr:`yatron.Board.t`).

    >>> them = board.them
    >>> them
    (3, 3)

As you can see, the coordinates start from the lower left corner. The first
coordinate is the X axis, the second is the Y axis. We can ask for any
coordinate on the boar like this:

    >>> board[0, 0]
    '#'

    >>> board[me]
    '1'

    >>> board[them]
    '2'

    >>> board[10, 10]
    Traceback (most recent call last):
    ...
    IndexError: tuple index out of range

You can use the object's field markers for comparison:

    >>> assert all(((board.ME  == '1'),
    ...     (board.THEM == '2'),
    ...     (board.WALL == '#'),
    ...     (board.FLOOR == ' '),
    ... ))

If we iterate over the board, it will yield it's blocks and coordinates:

    >>> for block, coords in board:
    ...     print block, coords
    # (0, 0)
    # (1, 0)
    ...
    1 (1, 1)
    ...
    2 (3, 3)
    ...
    # (4, 4)

To check for possible moves from a certain position, we call
:func:`yatron.Board.possibilities`.

    >>> board.possibilities(me)
    ((1, 2), (2, 1))

    >>> board.possibilities(them)
    ((3, 2), (2, 3))

To check the distance between us and the opponent, we can use the
:attr:`yatron.Board.distance` property.

    >>> board.distance
    3

Let's try it with a more complex board:

    >>> sys.stdin = StringIO("""7 5
    ... #######
    ... #   #2#
    ... # # # #
    ... #1#   #
    ... #######
    ... """)

    >>> board = generate().next()
    >>> board.distance
    9

Or an even more complex one:

    >>> sys.stdin = StringIO("""14 10
    ... ##############
    ... #            #
    ... #          2 #
    ... #   ######   #
    ... #   #    #   #
    ... #   #    #   #
    ... #   ######   #
    ... # 1          #
    ... #            #
    ... ##############
    ... """)

    >>> board = generate().next()
    >>> board.distance
    13

Let's try an isolated board:

    >>> sys.stdin = StringIO("""14 10
    ... ##############
    ... ###         ##
    ... #  #    #  2 #
    ... #   ######   #
    ... #      #     #
    ... #     #      #
    ... #   ######   #
    ... # 1  #    #  #
    ... ##         ###
    ... ##############
    ... """)

    >>> board = generate().next()
    >>> board.distance
    -1

Asking it the second time it should be slightly faster.

    >>> board.distance
    -1

Note that if we're isolated, calling distance will also calculate our space
left:

    >>> board.space
    35

If the two players are adjacent, the result is zero.

    >>> sys.stdin = StringIO("""7 6
    ... #######
    ... #     #
    ... #  2  #
    ... #  1  #
    ... #     #
    ... #######
    ... """)

    >>> board = generate().next()
    >>> board.distance
    0

To calculate one of the shortest paths between us and the opponent, we can use
the :attr:`yatron.Board.path` property.

    >>> board.path
    ()

    >>> sys.stdin = StringIO("""14 10
    ... ##############
    ... ###         ##
    ... #  #    #  2 #
    ... #   ######   #
    ... #       #    #
    ... #    #       #
    ... #   ######   #
    ... # 1  #    #  #
    ... ##         ###
    ... ##############
    ... """)

    >>> board = generate().next()
    >>> board.path
    ((2, 3), (2, 4), (2, 5), ..., (10, 5), (10, 6), (10, 7))

To get directions for an adjacent coordinate, call
:meth:`yatron.Board.direction`.

    >>> board.direction((2, 3))
    1

    >>> board.direction((board.me[0]-1, board.me[1])) == board.WEST
    True

Thus, if we want to head towards the enemy, we can easily get directions:

    >>> board.direction(board.path[0]) == board.NORTH
    True
